#!/usr/bin/env python3

import sys, copy, json, argparse
sys.path.insert(0, 'Prism')
sys.path.insert(0, 'Util')


import prism_compute as Computer
import prism_encode_adv as Encoder
import prism_extension_adv as Prism
import dataHandler as Data
import helper as Helper


# Common setup
ap = argparse.ArgumentParser()
ap.add_argument("-f", "--func", required = True, help = "function want to run")
ap.add_argument("-m", "--major", required = False, help = "major want to train")
ap.add_argument("-q", "--query", required = False, help = "the raw query want to predict")
ap.add_argument("-q2", "--queryEncoded", required = False, help = "the query encoded want to predict")
ap.add_argument("-p", "--trainedPath", required = False, help = "the trained data path")
ap.add_argument("-c", "--configurePath", required = False, help = "configure data files path")
args = vars(ap.parse_args())


# --- TRAIN ---
def processExtension(result,
 lastFrequent, lastItemIndex,
 lastSeqBlocks, lastOffsets, lastPosBlocks,
 seqBlocksList, posOffsetsList, posBlocksList, 
 items, isSeqExt):
	
	lengthOfItems = len(items)

	for itemIndex in range(lastItemIndex, lengthOfItems):
		curItem 							= items[itemIndex]
		seqBlockTarget 				= seqBlocksList[itemIndex]
		posOffsetsListTarget 	= posOffsetsList[itemIndex]
		posBlocksTarget 			= posBlocksList[itemIndex]

		(seqBlocksExt, posOffsetsExt, posBlocksExt) = Prism.extend(
			lastFrequent, curItem,
			lastSeqBlocks, seqBlockTarget,
			lastOffsets, posOffsetsListTarget,
			lastPosBlocks, posBlocksTarget,
			isSeqExt
		)

		supp = Computer.countSupportFromPrimalArray(seqBlocksExt)
		
		if not Computer.isValidSupport(supp): 
			continue

		if isSeqExt:
			lastFrequent += "->{0}".format(curItem)
			numerOfCharsRemove = 2
		else:
			lastFrequent += ".{0}".format(curItem)
			numerOfCharsRemove = 1

		# Ensure to make a copy instead of assign reference
		_lastSeqBlocks 	= copy.deepcopy(seqBlocksExt)
		_lastPosOffsets = copy.deepcopy(posOffsetsExt)
		_lastPosBlocks 	= copy.deepcopy(posBlocksExt)

		# Sequence extension
		processExtension(result, lastFrequent, 0,
			_lastSeqBlocks, _lastPosOffsets, _lastPosBlocks, 
			seqBlocksList, posOffsetsList, posBlocksList, 
			items, True)

		# Itemset extension
		processExtension(result, lastFrequent, itemIndex + 1, 
			_lastSeqBlocks, _lastPosOffsets, _lastPosBlocks, 
			seqBlocksList, posOffsetsList, posBlocksList, 
			items, False)

		result.append({
			"frequent": lastFrequent,
			"support": supp
		})
		print("[x] New frequent {0} has support {1}".format(lastFrequent, supp))

		numerOfCharsRemove += len(curItem)
		lastFrequent = lastFrequent[:-numerOfCharsRemove]
			
	return


def train(major, configurePath):
	with open(configurePath) as fp:
		conf = json.load(fp)

	trainedFolderPath = conf["TRAINED_FOLDER_PATH"]
	recordEncodedPath = conf["RECORD_ENCODED_PATH"]
	labelEncodedPath 	= conf["LABEL_ENCODED_PATH"]

	print("> Loading data encoded from data/ ...")
	(sequences, items) = Data.loadData(recordEncodedPath, labelEncodedPath)

	print("> Encode all records ...")
	(primalBlocks, posOffsetList) = Encoder.encodePrimalItemsetsAdv(items, sequences)
	seqBlocks = Encoder.encodePrimalSeqsAdv(items, sequences)

	numberOfItems = len(items)
	result = []

	print("> Start training ...")
	for itemIndex in range(0, numberOfItems):
		seqBlockOfItem 			= seqBlocks[itemIndex]
		primalOffetsOfItem 	= posOffsetList[itemIndex]
		primalBlockOfItem 	= primalBlocks[itemIndex]

		print("-> Label {0} is processing ...".format(items[itemIndex]))

		processExtension(result, items[itemIndex], 0,
			seqBlockOfItem , primalOffetsOfItem, primalBlockOfItem, 
			seqBlocks, posOffsetList, primalBlocks,
			items, True
		)

		processExtension(result, items[itemIndex], itemIndex + 1,
			seqBlockOfItem, primalOffetsOfItem, primalBlockOfItem, 
			seqBlocks, posOffsetList, primalBlocks,
			items, False
		)

	print("> Training done")
	# for element in result:
	# 	print("{0} - {1}".format(element["frequent"], element["support"]))
	
	Helper.saveTrainedData(result, major, trainedFolderPath)
	return
# --- END TRAIN ---


# --- PREDICT ----
def searchItemset(itemset, itemsetTarget):
	itemsetComponents = itemset.split(".")

	for item in itemsetComponents:
		if string(itemsetTarget).findAdv(item) == -1:
			return False

	return True


def predict(query, queryEncoded, trainedDataPath, configurePath):
	if queryEncoded:
		_queryEncoded = queryEncoded
	else:
		with open(configurePath) as fp:
			conf = json.load(fp)
		labelMappingPath 	= conf["LABEL_MAPPING_PATH"]
		_queryEncoded 		= Encoder.encodeQuery(query, labelMappingPath)
	
	trainedDataList = Helper.loadTrainedData(trainedDataPath)

	# Split based on sequence
	itemsetQueryComponents 				= _queryEncoded.split("->")
	itemsetQueryComponentsLength 	= len(itemsetQueryComponents)

	for trainedData in trainedDataList:
		trainedItemsetComponents = trainedData["frequent"].split("->")
		idxQuery = 0

		for itemset in trainedItemsetComponents:
			itemsetQuery = itemsetQueryComponents[idxQuery]
			idxQuery += 1 if searchItemset(itemsetQuery, itemset) else -idxQuery

			if idxQuery == itemsetQueryComponentsLength:
				print("{0} - {1}".format(trainedData["frequent"], trainedData["support"]))
				break

	return
# --- END PREDICT ---


# --- SHOW ----
def showTrained(filePath):
	trainedData = Helper.loadTrainedData(filePath)
	[print(item) for item in trainedData]
	return
# --- END SHOW ---


def usage():
	print("./run")
	print("... -f train -m <major> -c <configure file path>" )
	print("... -f predict -q \"<raw query>\" -c <configure file path> -p <trained data path>")
	print("... -f predict -q2 \"<query encoded>\" -c <configure file path> -p <trained data path>")
	print("... -f show -p <trained data path>")
	print("... -f encode -m <major> -c <configure file path>")
	print("... -f flat_record -m <major> -c <configure file path>")
	exit(0)


def parseParam(args):
	func 					= args["func"]
	major 				= args["major"] 				if "major" in args 					else None
	query 				= args["query"] 				if "query" in args 					else None
	queryEncoded	= args["queryEncoded"] 	if "queryEncoded" in args 	else None
	trainedPath 	= args["trainedPath"]		if "trainedPath" in args 		else None
	configurePath = args["configurePath"] if "configurePath" in args 	else None

	if major:
		major = major.upper()

	if func == "encode":
		if not major or not configurePath:
			usage()

		Data.processEncode(major, configurePath)

	elif func == "flat_record":
		if not major or not configurePath:
			usage()

		Data.processFlatRecord(major, configurePath) 

	elif func == "train":	
		if not major or not configurePath:
			usage()
			
		train(major, configurePath)

	elif func == "predict":
		if (not query and not queryEncoded) or (not trainedPath or not configurePath):
			usage()

		predict(query, queryEncoded, trainedPath,  configurePath)

	elif func == "show":
		if not trainedPath:
			usage()

		showTrained(trainedPath)

	else:
		usage()


if __name__ == "__main__":
	parseParam(args)
	




