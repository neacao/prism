#!/usr/bin/env python3

import sys, copy, json, datetime
sys.path.insert(0, 'Resource')
sys.path.insert(0, 'Prism')
sys.path.insert(0, '../data')

import prism_compute as Computer
import prism_encode_adv as Encoder
import prism_extension_adv as Prism
import dataHandler as Data
from constant import *
from helper import *


SEQ_SORTED_DATA_PATH = "Resource/seqSorted.data"


def processExtension(result, lastFrequent, lastItemIndex,
 lastSeqBlocks, lastOffsets, lastPosBlocks,
 seqBlocksList, posOffsetsList, posBlocksList, 
 items, isSeqExt):
	
	lengthOfItems = len(items)

	for itemIndex in range(lastItemIndex, lengthOfItems):
		curItem 							= items[itemIndex]
		seqBlockTarget 				= seqBlocksList[itemIndex]
		posOffsetsListTarget 	= posOffsetsList[itemIndex]
		posBlocksTarget 			= posBlocksList[itemIndex]

		(seqBlocksExt, posOffsetsExt, posBlocksExt) = Prism.extend(
			lastFrequent, curItem,
			lastSeqBlocks, seqBlockTarget,
			lastOffsets, posOffsetsListTarget,
			lastPosBlocks, posBlocksTarget,
			isSeqExt
		)

		supp = Computer.computeSupportOfPrimalValueArray(seqBlocksExt)
		
		if supp >= MIN_SUPP:
			if isSeqExt == True:
				lastFrequent += "->{0}".format(curItem)
			else:
				lastFrequent += ".{0}".format(curItem)

			# Ensure to make a copy instead of assign reference
			_lastSeqBlocks 	= copy.deepcopy(seqBlocksExt)
			_lastPosOffsets = copy.deepcopy(posOffsetsExt)
			_lastPosBlocks 	= copy.deepcopy(posBlocksExt)

			# Sequence extension
			processExtension(result, lastFrequent, 0,
				_lastSeqBlocks, _lastPosOffsets, _lastPosBlocks, 
				seqBlocksList, posOffsetsList, posBlocksList, 
				items, True)

			# Itemset extension
			processExtension(result, lastFrequent, itemIndex + 1, 
				_lastSeqBlocks, _lastPosOffsets, _lastPosBlocks, 
				seqBlocksList, posOffsetsList, posBlocksList, 
				items, False) 

			result.append({
				"frequent": lastFrequent,
				"support": supp
			})
			print("=> New frequent {0} has support {1}".format(lastFrequent, supp))

			numerOfCharsRemove = len(curItem)
			if isSeqExt == True:
				numerOfCharsRemove += 2
			else:
				numerOfCharsRemove += 1

			lastFrequent = lastFrequent[:-numerOfCharsRemove]

	return
 

def saveTrainedData(result, major):
	now = datetime.datetime.now()
	fileName = "Resource/{0}_{1}".format(major, now.isoformat())
	with open(fileName, "w") as fp:
		json.dump(result, fp)


def saveSortedSeq(seqs):
	with open(SEQ_SORTED_DATA_PATH, "w") as fp:
		for seq in seqs:
			fp.write("{0}\n".format(string(seq)))


def train(major):
	(sequences, items) = Data.loadData(major)
	# Sorted to make sure item will not overlap each other when process item extension
	items = sorted(items)
	sequences = [sortAdv(seq) for seq in sequences]
	saveSortedSeq(sequences)

	length = len(sequences)
	for index in range(0, length):
		print("{0} {1}".format(index, sequences[index]))

	(itemsPosBlocks, itemsPosOffsets) = Encoder.processEncodePrimalBlockAllSequences(items, sequences)
	seqBlocks = Encoder.processEncodePrimalSeqAdv(items, sequences)

	numberOfItems = len(items)
	result = [] * numberOfItems

	for index in range(0, numberOfItems):
		processExtension(result, items[index], 0,
			seqBlocks[index], itemsPosOffsets[index], itemsPosBlocks[index], 
			seqBlocks, itemsPosOffsets, itemsPosBlocks,
			items, True
		)

		processExtension(result, items[index], index + 1,
			seqBlocks[index], itemsPosOffsets[index], itemsPosBlocks[index], 
			seqBlocks, itemsPosOffsets, itemsPosBlocks,
			items, False
		)
	
	for element in result:
		print("{0} - {1}".format(element["frequent"], element["support"]))
	
	saveTrainedData(result, major)


def loadTrainedData(filePath):
	with open(filePath) as fp:
		trainedData = json.load(fp)
	return trainedData


def predict(query, trainedDataPath):
	trainedData = loadTrainedData(trainedDataPath)

	for element in trainedData:
		isExist = True if element["frequent"].find(query) != -1 else False
		if isExist:
			print("{0} - {1}".format(element["frequent"], element["support"]))

	return


def showTrained(major):
	with open(TRAIN_DATA_PATH) as fp:
		data = fp.readlines()

	jsonObject = json.loads(data[0])
	for item in jsonObject:
		print(item)

	return


def usage():
	print("./run")
	print("... train [ IT ]")
	print("... predict \"A.B->C\" <trainedDataPath>")
	print("... show [ IT ]")
	return


if __name__ == "__main__":
	
	numberOfFunc = 3
	argv = sys.argv

	if len(argv) < numberOfFunc:
		usage()
		exit(0)

	func = argv[1]

	if func == "train":
		major = argv[2].lower()
		train(major)

	elif func == "predict":
		query = argv[2]
		trainedDataPath = argv[3]
		predict(query, trainedDataPath)

	elif func == "show":
		major = argv[2].lower()  
		showTrained(major)

	else:
		usage()




